var P=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),V=(e,n)=>e<<32-n|e>>>n,vt=class{clone(){return this._cloneInto()}};function Et(e){let n=r=>e().update(toBytes(r)).digest(),t=e();return n.outputLen=t.outputLen,n.blockLen=t.blockLen,n.create=()=>e(),n}function Bt(e=32){if(crypto&&typeof crypto.getRandomValues=="function")return crypto.getRandomValues(new Uint8Array(e));if(crypto&&typeof crypto.randomBytes=="function")return crypto.randomBytes(e);throw new Error("crypto.getRandomValues must be defined")}var xt=(e,n,t)=>e&n^~e&t,St=(e,n,t)=>e&n^e&t^n&t,At=class extends vt{constructor(e,n,t,r){super(),this.blockLen=e,this.outputLen=n,this.padOffset=t,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=P(this.buffer)}update(e){aexists(this);let{view:n,buffer:t,blockLen:r}=this;e=toBytes(e);let s=e.length;for(let o=0;o<s;){let u=Math.min(r-this.pos,s-o);if(u===r){let f=P(e);for(;r<=s-o;o+=r)this.process(f,o);continue}t.set(e.subarray(o,o+u),this.pos),this.pos+=u,o+=u,this.pos===r&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){aexists(this),aoutput(e,this),this.finished=!0;let{buffer:n,view:t,blockLen:r,isLE:s}=this,{pos:o}=this;n[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>r-o&&(this.process(t,0),o=0);for(let h=o;h<r;h++)n[h]=0;setBigUint64(t,r-8,BigInt(this.length*8),s),this.process(t,0);let u=P(e),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let i=f/4,d=this.get();if(i>d.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<i;h++)u.setUint32(4*h,d[h],s)}digest(){let{buffer:e,outputLen:n}=this;this.digestInto(e);let t=e.slice(0,n);return this.destroy(),t}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:n,buffer:t,length:r,finished:s,destroyed:o,pos:u}=this;return e.length=r,e.pos=u,e.finished=s,e.destroyed=o,r%n&&e.buffer.set(t),e}},Nt=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),k=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),H=new Uint32Array(64),Ot=class extends At{constructor(){super(64,32,8,!1),this.A=k[0]|0,this.B=k[1]|0,this.C=k[2]|0,this.D=k[3]|0,this.E=k[4]|0,this.F=k[5]|0,this.G=k[6]|0,this.H=k[7]|0}get(){let{A:e,B:n,C:t,D:r,E:s,F:o,G:u,H:f}=this;return[e,n,t,r,s,o,u,f]}set(e,n,t,r,s,o,u,f){this.A=e|0,this.B=n|0,this.C=t|0,this.D=r|0,this.E=s|0,this.F=o|0,this.G=u|0,this.H=f|0}process(e,n){for(let h=0;h<16;h++,n+=4)H[h]=e.getUint32(n,!1);for(let h=16;h<64;h++){let g=H[h-15],x=H[h-2],A=V(g,7)^V(g,18)^g>>>3,w=V(x,17)^V(x,19)^x>>>10;H[h]=w+H[h-7]+A+H[h-16]|0}let{A:t,B:r,C:s,D:o,E:u,F:f,G:i,H:d}=this;for(let h=0;h<64;h++){let g=V(u,6)^V(u,11)^V(u,25),x=d+g+xt(u,f,i)+Nt[h]+H[h]|0,w=(V(t,2)^V(t,13)^V(t,22))+St(t,r,s)|0;d=i,i=f,f=u,u=o+x|0,o=s,s=r,r=t,t=x+w|0}t=t+this.A|0,r=r+this.B|0,s=s+this.C|0,o=o+this.D|0,u=u+this.E|0,f=f+this.F|0,i=i+this.G|0,d=d+this.H|0,this.set(t,r,s,o,u,f,i,d)}roundClean(){H.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}},qt=Et(()=>new Ot),ht=0n,It=1n,Lt=2n;function W(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Zt(e){if(!W(e))throw new Error("Uint8Array expected")}var zt=Array.from({length:256},(e,n)=>n.toString(16).padStart(2,"0"));function ot(e){Zt(e);let n="";for(let t=0;t<e.length;t++)n+=zt[e[t]];return n}function Tt(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?ht:BigInt("0x"+e)}var R={_0:48,_9:57,A:65,F:70,a:97,f:102};function at(e){if(e>=R._0&&e<=R._9)return e-R._0;if(e>=R.A&&e<=R.F)return e-(R.A-10);if(e>=R.a&&e<=R.f)return e-(R.a-10)}function K(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);let n=e.length,t=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);let r=new Uint8Array(t);for(let s=0,o=0;s<t;s++,o+=2){let u=at(e.charCodeAt(o)),f=at(e.charCodeAt(o+1));if(u===void 0||f===void 0){let i=e[o]+e[o+1];throw new Error('hex string expected, got non-hex character "'+i+'" at index '+o)}r[s]=u*16+f}return r}function j(e){return Tt(ot(e))}function wt(e,n){return K(e.toString(16).padStart(n*2,"0"))}function D(e,n,t){let r;if(typeof n=="string")try{r=K(n)}catch(o){throw new Error(e+" must be hex string or Uint8Array, cause: "+o)}else if(W(n))r=Uint8Array.from(n);else throw new Error(e+" must be hex string or Uint8Array");let s=r.length;if(typeof t=="number"&&s!==t)throw new Error(e+" of length "+t+" expected, got "+s);return r}var Q=e=>typeof e=="bigint"&&ht<=e;function st(e,n,t){return Q(e)&&Q(n)&&Q(t)&&n<=e&&e<t}function F(e,n,t,r){if(!st(n,t,r))throw new Error("expected valid "+e+": "+t+" <= n < "+r+", got "+n)}var Ct=e=>(Lt<<BigInt(e-1))-It,Ut={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||W(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,n)=>n.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function X(e,n,t={}){let r=(s,o,u)=>{let f=Ut[o];if(typeof f!="function")throw new Error("invalid validator function");let i=e[s];if(!(u&&i===void 0)&&!f(i,e))throw new Error("param "+String(s)+" is invalid. Expected "+o+", got "+i)};for(let[s,o]of Object.entries(n))r(s,o,!1);for(let[s,o]of Object.entries(t))r(s,o,!0);return e}function ft(e){let n=new WeakMap;return(t,...r)=>{let s=n.get(t);if(s!==void 0)return s;let o=e(t,...r);return n.set(t,o),o}}var I=BigInt(0),O=BigInt(1),_=BigInt(2),Vt=BigInt(3),rt=BigInt(4),ct=BigInt(5),ut=BigInt(8),Rt=BigInt(9),kt=BigInt(16);function C(e,n){let t=e%n;return t>=I?t:n+t}function Ht(e,n,t){if(n<I)throw new Error("invalid exponent, negatives unsupported");if(t<=I)throw new Error("invalid modulus");if(t===O)return I;let r=O;for(;n>I;)n&O&&(r=r*e%t),e=e*e%t,n>>=O;return r}function it(e,n){if(e===I)throw new Error("invert: expected non-zero number");if(n<=I)throw new Error("invert: expected positive modulus, got "+n);let t=C(e,n),r=n,s=I,o=O,u=O,f=I;for(;t!==I;){let d=r/t,h=r%t,g=s-u*d,x=o-f*d;r=t,t=h,s=u,o=f,u=g,f=x}if(r!==O)throw new Error("invert: does not exist");return C(s,n)}function _t(e){let n=(e-O)/_,t,r,s;for(t=e-O,r=0;t%_===I;t/=_,r++);for(s=_;s<e&&Ht(s,n,e)!==e-O;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){let u=(e+O)/rt;return function(i,d){let h=i.pow(d,u);if(!i.eql(i.sqr(h),d))throw new Error("Cannot find square root");return h}}let o=(t+O)/_;return function(f,i){if(f.pow(i,n)===f.neg(f.ONE))throw new Error("Cannot find square root");let d=r,h=f.pow(f.mul(f.ONE,s),t),g=f.pow(i,o),x=f.pow(i,t);for(;!f.eql(x,f.ONE);){if(f.eql(x,f.ZERO))return f.ZERO;let A=1;for(let a=f.sqr(x);A<d&&!f.eql(a,f.ONE);A++)a=f.sqr(a);let w=f.pow(h,O<<BigInt(d-A-1));h=f.sqr(w),g=f.mul(g,w),x=f.mul(x,h),d=A}return g}}function Mt(e){if(e%rt===Vt){let n=(e+O)/rt;return function(r,s){let o=r.pow(s,n);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(e%ut===ct){let n=(e-ct)/ut;return function(r,s){let o=r.mul(s,_),u=r.pow(o,n),f=r.mul(s,u),i=r.mul(r.mul(f,_),u),d=r.mul(f,r.sub(i,r.ONE));if(!r.eql(r.sqr(d),s))throw new Error("Cannot find square root");return d}}return e%kt,_t(e)}var Yt=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function jt(e){let n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Yt.reduce((r,s)=>(r[s]="function",r),n);return X(e,t)}function Ft(e,n,t){if(t<I)throw new Error("invalid exponent, negatives unsupported");if(t===I)return e.ONE;if(t===O)return n;let r=e.ONE,s=n;for(;t>I;)t&O&&(r=e.mul(r,s)),s=e.sqr(s),t>>=O;return r}function Gt(e,n){let t=new Array(n.length),r=n.reduce((o,u,f)=>e.is0(u)?o:(t[f]=o,e.mul(o,u)),e.ONE),s=e.inv(r);return n.reduceRight((o,u,f)=>e.is0(u)?o:(t[f]=e.mul(o,t[f]),e.mul(o,u)),s),t}function gt(e,n){let t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function pt(e,n,t=!1,r={}){if(e<=I)throw new Error("invalid field: expected ORDER > 0, got "+e);let{nBitLength:s,nByteLength:o}=gt(e,n);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let u,f=Object.freeze({ORDER:e,isLE:t,BITS:s,BYTES:o,MASK:Ct(s),ZERO:I,ONE:O,create:i=>C(i,e),isValid:i=>{if(typeof i!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof i);return I<=i&&i<e},is0:i=>i===I,isOdd:i=>(i&O)===O,neg:i=>C(-i,e),eql:(i,d)=>i===d,sqr:i=>C(i*i,e),add:(i,d)=>C(i+d,e),sub:(i,d)=>C(i-d,e),mul:(i,d)=>C(i*d,e),pow:(i,d)=>Ft(f,i,d),div:(i,d)=>C(i*it(d,e),e),sqrN:i=>i*i,addN:(i,d)=>i+d,subN:(i,d)=>i-d,mulN:(i,d)=>i*d,inv:i=>it(i,e),sqrt:r.sqrt||(i=>(u||(u=Mt(e)),u(f,i))),invertBatch:i=>Gt(f,i),cmov:(i,d,h)=>h?d:i,toBytes:i=>t?numberToBytesLE(i,o):wt(i,o),fromBytes:i=>{if(i.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+i.length);return t?bytesToNumberLE(i):j(i)}});return Object.freeze(f)}var lt=BigInt(0),G=BigInt(1);function J(e,n){let t=n.negate();return e?t:n}function mt(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function $(e,n){mt(e,n);let t=Math.ceil(n/e)+1,r=2**(e-1);return{windows:t,windowSize:r}}var tt=new WeakMap,yt=new WeakMap;function et(e){return yt.get(e)||1}function Kt(e,n){return{constTimeNegate:J,hasPrecomputes(t){return et(t)!==1},unsafeLadder(t,r,s=e.ZERO){let o=t;for(;r>lt;)r&G&&(s=s.add(o)),o=o.double(),r>>=G;return s},precomputeWindow(t,r){let{windows:s,windowSize:o}=$(r,n),u=[],f=t,i=f;for(let d=0;d<s;d++){i=f,u.push(i);for(let h=1;h<o;h++)i=i.add(f),u.push(i);f=i.double()}return u},wNAF(t,r,s){let{windows:o,windowSize:u}=$(t,n),f=e.ZERO,i=e.BASE,d=BigInt(2**t-1),h=2**t,g=BigInt(t);for(let x=0;x<o;x++){let A=x*u,w=Number(s&d);s>>=g,w>u&&(w-=h,s+=G);let a=A,c=A+Math.abs(w)-1,l=x%2!==0,p=w<0;w===0?i=i.add(J(l,r[a])):f=f.add(J(p,r[c]))}return{p:f,f:i}},wNAFUnsafe(t,r,s,o=e.ZERO){let{windows:u,windowSize:f}=$(t,n),i=BigInt(2**t-1),d=2**t,h=BigInt(t);for(let g=0;g<u;g++){let x=g*f;if(s===lt)break;let A=Number(s&i);if(s>>=h,A>f&&(A-=d,s+=G),A===0)continue;let w=r[x+Math.abs(A)-1];A<0&&(w=w.negate()),o=o.add(w)}return o},getPrecomputes(t,r,s){let o=tt.get(r);return o||(o=this.precomputeWindow(r,t),t!==1&&tt.set(r,s(o))),o},wNAFCached(t,r,s){let o=et(t);return this.wNAF(o,this.getPrecomputes(o,t,s),r)},wNAFCachedUnsafe(t,r,s,o){let u=et(t);return u===1?this.unsafeLadder(t,r,o):this.wNAFUnsafe(u,this.getPrecomputes(u,t,s),r,o)},setWindowSize(t,r){mt(r,n),yt.set(t,r),tt.delete(t)}}}function bt(e){return jt(e.Fp),X(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...gt(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}function Dt(e){let n=bt(e);X(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:t,Fp:r,a:s}=n;if(t){if(!r.eql(s,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...n})}var Y=BigInt(0),Z=BigInt(1),dt=BigInt(3);function Wt(e){let n=Dt(e),{Fp:t}=n,r=pt(n.n,n.nBitLength),s=n.fromBytes||(w=>{let a=w.subarray(1),c=t.fromBytes(a.subarray(0,t.BYTES)),l=t.fromBytes(a.subarray(t.BYTES,2*t.BYTES));return{x:c,y:l}});function o(w){let{a,b:c}=n,l=t.sqr(w),p=t.mul(l,w);return t.add(t.add(p,t.mul(w,a)),c)}if(!t.eql(t.sqr(n.Gy),o(n.Gx)))throw new Error("bad generator point: equation left != right");function u(w){return st(w,Z,n.n)}function f(w){let{allowedPrivateKeyLengths:a,nByteLength:c,wrapPrivateKey:l,n:p}=n;if(a&&typeof w!="bigint"){if(W(w)&&(w=ot(w)),typeof w!="string"||!a.includes(w.length))throw new Error("invalid private key");w=w.padStart(c*2,"0")}let y;try{y=typeof w=="bigint"?w:j(D("private key",w,c))}catch{throw new Error("invalid private key, expected hex or "+c+" bytes, got "+typeof w)}return l&&(y=C(y,p)),F("private key",y,Z,p),y}function i(w){if(!(w instanceof g))throw new Error("ProjectivePoint expected")}let d=ft((w,a)=>{let{px:c,py:l,pz:p}=w;if(t.eql(p,t.ONE))return{x:c,y:l};let y=w.is0();a==null&&(a=y?t.ONE:t.inv(p));let B=t.mul(c,a),v=t.mul(l,a),b=t.mul(p,a);if(y)return{x:t.ZERO,y:t.ZERO};if(!t.eql(b,t.ONE))throw new Error("invZ was invalid");return{x:B,y:v}}),h=ft(w=>{if(w.is0()){if(n.allowInfinityPoint&&!t.is0(w.py))return;throw new Error("bad point: ZERO")}let{x:a,y:c}=w.toAffine();if(!t.isValid(a)||!t.isValid(c))throw new Error("bad point: x or y not FE");let l=t.sqr(c),p=o(a);if(!t.eql(l,p))throw new Error("bad point: equation left != right");if(!w.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(a,c,l){if(this.px=a,this.py=c,this.pz=l,a==null||!t.isValid(a))throw new Error("x required");if(c==null||!t.isValid(c))throw new Error("y required");if(l==null||!t.isValid(l))throw new Error("z required");Object.freeze(this)}static fromAffine(a){let{x:c,y:l}=a||{};if(!a||!t.isValid(c)||!t.isValid(l))throw new Error("invalid affine point");if(a instanceof g)throw new Error("projective point not allowed");let p=y=>t.eql(y,t.ZERO);return p(c)&&p(l)?g.ZERO:new g(c,l,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){let c=t.invertBatch(a.map(l=>l.pz));return a.map((l,p)=>l.toAffine(c[p])).map(g.fromAffine)}static fromHex(a){let c=g.fromAffine(s(D("pointHex",a)));return c.assertValidity(),c}static msm(a,c){return pippenger(g,r,a,c)}_setWindowSize(a){A.setWindowSize(this,a)}assertValidity(){h(this)}hasEvenY(){let{y:a}=this.toAffine();if(t.isOdd)return!t.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){i(a);let{px:c,py:l,pz:p}=this,{px:y,py:B,pz:v}=a,b=t.eql(t.mul(c,v),t.mul(y,p)),E=t.eql(t.mul(l,v),t.mul(B,p));return b&&E}negate(){return new g(this.px,t.neg(this.py),this.pz)}double(){let{a,b:c}=n,l=t.mul(c,dt),{px:p,py:y,pz:B}=this,v=t.ZERO,b=t.ZERO,E=t.ZERO,m=t.mul(p,p),q=t.mul(y,y),N=t.mul(B,B),S=t.mul(p,y);return S=t.add(S,S),E=t.mul(p,B),E=t.add(E,E),v=t.mul(a,E),b=t.mul(l,N),b=t.add(v,b),v=t.sub(q,b),b=t.add(q,b),b=t.mul(v,b),v=t.mul(S,v),E=t.mul(l,E),N=t.mul(a,N),S=t.sub(m,N),S=t.mul(a,S),S=t.add(S,E),E=t.add(m,m),m=t.add(E,m),m=t.add(m,N),m=t.mul(m,S),b=t.add(b,m),N=t.mul(y,B),N=t.add(N,N),m=t.mul(N,S),v=t.sub(v,m),E=t.mul(N,q),E=t.add(E,E),E=t.add(E,E),new g(v,b,E)}add(a){i(a);let{px:c,py:l,pz:p}=this,{px:y,py:B,pz:v}=a,b=t.ZERO,E=t.ZERO,m=t.ZERO,q=n.a,N=t.mul(n.b,dt),S=t.mul(c,y),z=t.mul(l,B),T=t.mul(p,v),M=t.add(c,l),L=t.add(y,B);M=t.mul(M,L),L=t.add(S,z),M=t.sub(M,L),L=t.add(c,p);let U=t.add(y,v);return L=t.mul(L,U),U=t.add(S,T),L=t.sub(L,U),U=t.add(l,p),b=t.add(B,v),U=t.mul(U,b),b=t.add(z,T),U=t.sub(U,b),m=t.mul(q,L),b=t.mul(N,T),m=t.add(b,m),b=t.sub(z,m),m=t.add(z,m),E=t.mul(b,m),z=t.add(S,S),z=t.add(z,S),T=t.mul(q,T),L=t.mul(N,L),z=t.add(z,T),T=t.sub(S,T),T=t.mul(q,T),L=t.add(L,T),S=t.mul(z,L),E=t.add(E,S),S=t.mul(U,L),b=t.mul(M,b),b=t.sub(b,S),S=t.mul(M,z),m=t.mul(U,m),m=t.add(m,S),new g(b,E,m)}subtract(a){return this.add(a.negate())}is0(){return this.equals(g.ZERO)}wNAF(a){return A.wNAFCached(this,a,g.normalizeZ)}multiplyUnsafe(a){let{endo:c,n:l}=n;F("scalar",a,Y,l);let p=g.ZERO;if(a===Y)return p;if(this.is0()||a===Z)return this;if(!c||A.hasPrecomputes(this))return A.wNAFCachedUnsafe(this,a,g.normalizeZ);let{k1neg:y,k1:B,k2neg:v,k2:b}=c.splitScalar(a),E=p,m=p,q=this;for(;B>Y||b>Y;)B&Z&&(E=E.add(q)),b&Z&&(m=m.add(q)),q=q.double(),B>>=Z,b>>=Z;return y&&(E=E.negate()),v&&(m=m.negate()),m=new g(t.mul(m.px,c.beta),m.py,m.pz),E.add(m)}multiply(a){let{endo:c,n:l}=n;F("scalar",a,Z,l);let p,y;if(c){let{k1neg:B,k1:v,k2neg:b,k2:E}=c.splitScalar(a),{p:m,f:q}=this.wNAF(v),{p:N,f:S}=this.wNAF(E);m=A.constTimeNegate(B,m),N=A.constTimeNegate(b,N),N=new g(t.mul(N.px,c.beta),N.py,N.pz),p=m.add(N),y=q.add(S)}else{let{p:B,f:v}=this.wNAF(a);p=B,y=v}return g.normalizeZ([p,y])[0]}multiplyAndAddUnsafe(a,c,l){let p=g.BASE,y=(v,b)=>b===Y||b===Z||!v.equals(p)?v.multiplyUnsafe(b):v.multiply(b),B=y(this,c).add(y(a,l));return B.is0()?void 0:B}toAffine(a){return d(this,a)}isTorsionFree(){let{h:a,isTorsionFree:c}=n;if(a===Z)return!0;if(c)return c(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}}g.BASE=new g(n.Gx,n.Gy,t.ONE),g.ZERO=new g(t.ZERO,t.ONE,t.ZERO);let x=n.nBitLength,A=Kt(g,n.endo?Math.ceil(x/2):x);return{CURVE:n,ProjectivePoint:g,normPrivateKeyToScalar:f,weierstrassEquation:o,isWithinCurveOrder:u}}function Xt(e){let n=bt(e);return X(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Pt(e){let n=Xt(e),{Fp:t,n:r}=n,s=t.BYTES+1,o=2*t.BYTES+1;function u(a){return C(a,r)}function f(a){return it(a,r)}let{ProjectivePoint:i,weierstrassEquation:d}=Wt({...n,fromBytes(a){let c=a.length,l=a[0],p=a.subarray(1);if(c===s&&(l===2||l===3)){let y=j(p);if(!st(y,Z,t.ORDER))throw new Error("Point is not on curve");let B=d(y),v;try{v=t.sqrt(B)}catch(m){let q=m instanceof Error?": "+m.message:"";throw new Error("Point is not on curve"+q)}let b=(v&Z)===Z;return(l&1)===1!==b&&(v=t.neg(v)),{x:y,y:v}}else if(c===o&&l===4){let y=t.fromBytes(p.subarray(0,t.BYTES)),B=t.fromBytes(p.subarray(t.BYTES,2*t.BYTES));return{x:y,y:B}}else{let y=s,B=o;throw new Error("invalid Point, expected length of "+y+", or uncompressed "+B+", got "+c)}}}),h=a=>ot(wt(a,n.nByteLength)),g=(a,c,l)=>j(a.slice(c,l));class x{constructor(c,l,p){this.r=c,this.s=l,this.recovery=p,this.assertValidity()}static fromCompact(c){let l=n.nByteLength;return c=D("compactSignature",c,l*2),new x(g(c,0,l),g(c,l,2*l))}assertValidity(){F("r",this.r,Z,r),F("s",this.s,Z,r)}addRecoveryBit(c){return new x(this.r,this.s,c)}recoverPublicKey(c){let{r:l,s:p,recovery:y}=this,B=w(D("msgHash",c));if(y==null||![0,1,2,3].includes(y))throw new Error("recovery id invalid");let v=y===2||y===3?l+n.n:l;if(v>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");let b=y&1?"03":"02",E=i.fromHex(b+h(v)),m=f(v),q=u(-B*m),N=u(p*m),S=i.BASE.multiplyAndAddUnsafe(E,q,N);if(!S)throw new Error("point at infinify");return S.assertValidity(),S}hasHighS(){return isBiggerThanHalfOrder(this.s)}normalizeS(){return this.hasHighS()?new x(this.r,u(-this.s),this.recovery):this}toDERRawBytes(){return K(this.toDERHex())}toDERHex(){return DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return K(this.toCompactHex())}toCompactHex(){return h(this.r)+h(this.s)}}let A=n.bits2int||function(a){if(a.length>8192)throw new Error("input is too large");let c=j(a),l=a.length*8-n.nBitLength;return l>0?c>>BigInt(l):c},w=n.bits2int_modN||function(a){return u(A(a))};return i.BASE._setWindowSize(8),{CURVE:n,ProjectivePoint:i,Signature:x}}function Qt(e){return{hash:e,hmac:(n,...t)=>hmac(e,n,concatBytes(...t)),randomBytes:Bt}}function Jt(e,n){let t=r=>Pt({...e,...Qt(r)});return{...t(n),create:t}}var $t=pt(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),te=115792089210356248762697446949407573530086143415290314195533631308867097853948n,ee=0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604bn,nt=Jt({a:te,b:ee,Fp:$t,n:0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551n,Gx:0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296n,Gy:0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5n,h:1n,lowS:!1},qt);function ne(e,{r:n,s:t},r){let s=nt.ProjectivePoint.fromHex(e),u=new nt.Signature(n,t,0).recoverPublicKey(r);if(s.px==u.x)return 0;let i=new nt.Signature(n,t,1).recoverPublicKey(r);if(s.px==i.x)return 1;throw new Error("Unable to calculate the recovery ID for signature.")}export{ne as default};
